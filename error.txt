Testing started at 15:40 ...
C:\Users\tatyana\PycharmProjects\Devel\env\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2019.2\helpers\pycharm\_jb_pytest_runner.py" --path C:/Users/tatyana/PycharmProjects/Devel/test/test_check_all_contacts_data.py
Launching pytest with arguments C:/Users/tatyana/PycharmProjects/Devel/test/test_check_all_contacts_data.py in C:\Users\tatyana\PycharmProjects\Devel\test

============================= test session starts =============================
platform win32 -- Python 3.7.0, pytest-5.1.0, py-1.8.0, pluggy-0.12.0 -- C:\Users\tatyana\PycharmProjects\Devel\env\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\tatyana\PycharmProjects\Devel\test
plugins: bdd-3.2.1
collecting ... collected 1 item

test_check_all_contacts_data.py::test_check_all_contacts_data ERROR      [100%]
test setup failed
func = <function DBAPIProvider.connect at 0x000002365E3399D8>
provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>
args = (), kwargs = {}
dbapi_module = <module 'pymysql' from 'C:\\Users\\tatyana\\PycharmProjects\\Devel\\env\\lib\\site-packages\\pymysql\\__init__.py'>

    @decorator
    def wrap_dbapi_exceptions(func, provider, *args, **kwargs):
        dbapi_module = provider.dbapi_module
        try:
            if provider.dialect != 'SQLite':
>               return func(provider, *args, **kwargs)

..\env\lib\site-packages\pony\orm\dbapiprovider.py:50:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>

    @wrap_dbapi_exceptions
    def connect(provider):
>       return provider.pool.connect()

..\env\lib\site-packages\pony\orm\dbapiprovider.py:215:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pool = <pony.orm.dbapiprovider.Pool object at 0x000002365EC69648>

    def connect(pool):
        pid = os.getpid()
        if pool.con is not None and pool.pid != pid:
            pool.forked_connections.append((pool.con, pool.pid))
            pool.con = pool.pid = None
        core = pony.orm.core
        is_new_connection = False
        if pool.con is None:
            if core.local.debug: core.log_orm('GET NEW CONNECTION')
            is_new_connection = True
>           pool._connect()

..\env\lib\site-packages\pony\orm\dbapiprovider.py:336:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pool = <pony.orm.dbapiprovider.Pool object at 0x000002365EC69648>

    def _connect(pool):
>       pool.con = pool.dbapi_module.connect(*pool.args, **pool.kwargs)

..\env\lib\site-packages\pony\orm\dbapiprovider.py:342:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ()
kwargs = {'charset': 'utf8', 'client_flag': 2, 'conv': {<class 'bool'>: <function escape_bool at 0x000002365E36EAE8>, <class 'i...00002365E36EC80>, <class 'str'>: <function escape_unicode at 0x000002365E36EEA0>, ...}, 'database': 'addressbook', ...}
Connection = <class 'pymysql.connections.Connection'>

    def Connect(*args, **kwargs):
        """
        Connect to the database; see connections.Connection.__init__() for
        more information.
        """
        from .connections import Connection
>       return Connection(*args, **kwargs)

..\env\lib\site-packages\pymysql\__init__.py:94:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
host = '127.0.0.1', user = 'root', password = "db_config['password']"
database = 'addressbook', port = 0, unix_socket = None, charset = 'utf8'
sql_mode = None, read_default_file = None
conv = {<class 'bool'>: <function escape_bool at 0x000002365E36EAE8>, <class 'int'>: <function escape_int at 0x000002365E36EB...'>: <function escape_float at 0x000002365E36EC80>, <class 'str'>: <function escape_unicode at 0x000002365E36EEA0>, ...}
use_unicode = True, client_flag = 3842575
cursorclass = <class 'pymysql.cursors.Cursor'>, init_command = None
connect_timeout = 10, ssl = None, read_default_group = None, compress = None
named_pipe = None, autocommit = False, db = None, passwd = None
local_infile = False, max_allowed_packet = 16777216, defer_connect = False
auth_plugin_map = None, read_timeout = None, write_timeout = None
bind_address = None, binary_prefix = False, program_name = None
server_public_key = None

    def __init__(self, host=None, user=None, password="",
                 database=None, port=0, unix_socket=None,
                 charset='', sql_mode=None,
                 read_default_file=None, conv=None, use_unicode=None,
                 client_flag=0, cursorclass=Cursor, init_command=None,
                 connect_timeout=10, ssl=None, read_default_group=None,
                 compress=None, named_pipe=None,
                 autocommit=False, db=None, passwd=None, local_infile=False,
                 max_allowed_packet=16*1024*1024, defer_connect=False,
                 auth_plugin_map=None, read_timeout=None, write_timeout=None,
                 bind_address=None, binary_prefix=False, program_name=None,
                 server_public_key=None):
        if use_unicode is None and sys.version_info[0] > 2:
            use_unicode = True

        if db is not None and database is None:
            database = db
        if passwd is not None and not password:
            password = passwd

        if compress or named_pipe:
            raise NotImplementedError("compress and named_pipe arguments are not supported")

        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES

        if read_default_group and not read_default_file:
            if sys.platform.startswith("win"):
                read_default_file = "c:\\my.ini"
            else:
                read_default_file = "/etc/my.cnf"

        if read_default_file:
            if not read_default_group:
                read_default_group = "client"

            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))

            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg

            user = _config("user", user)
            password = _config("password", password)
            host = _config("host", host)
            database = _config("database", database)
            unix_socket = _config("socket", unix_socket)
            port = int(_config("port", port))
            bind_address = _config("bind-address", bind_address)
            charset = _config("default-character-set", charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in ["ca", "capath", "cert", "key", "cipher"]:
                    value = _config("ssl-" + key, ssl.get(key))
                    if value:
                        ssl[key] = value

        self.ssl = False
        if ssl:
            if not SSL_ENABLED:
                raise NotImplementedError("ssl module not found")
            self.ssl = True
            client_flag |= CLIENT.SSL
            self.ctx = self._create_ssl_ctx(ssl)

        self.host = host or "localhost"
        self.port = port or 3306
        self.user = user or DEFAULT_USER
        self.password = password or b""
        if isinstance(self.password, text_type):
            self.password = self.password.encode('latin1')
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 < connect_timeout <= 31536000):
            raise ValueError("connect_timeout should be >0 and <=31536000")
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout <= 0:
            raise ValueError("read_timeout should be >= 0")
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout <= 0:
            raise ValueError("write_timeout should be >= 0")
        self._write_timeout = write_timeout
        if charset:
            self.charset = charset
            self.use_unicode = True
        else:
            self.charset = DEFAULT_CHARSET
            self.use_unicode = False

        if use_unicode is not None:
            self.use_unicode = use_unicode

        self.encoding = charset_by_name(self.charset).encoding

        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB

        self.client_flag = client_flag

        self.cursorclass = cursorclass

        self._result = None
        self._affected_rows = 0
        self.host_info = "Not connected"

        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit

        if conv is None:
            conv = converters.conversions

        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key

        self._connect_attrs = {
            '_client_name': 'pymysql',
            '_pid': str(os.getpid()),
            '_client_version': VERSION_STRING,
        }

        if program_name:
            self._connect_attrs["program_name"] = program_name

        if defer_connect:
            self._sock = None
        else:
>           self.connect()

..\env\lib\site-packages\pymysql\connections.py:325:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG: print('connected using unix_socket')
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs['source_address'] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG: print('connected using socket')
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, 'rb')
            self._next_seq_id = 0

            self._get_server_information()
>           self._request_authentication()

..\env\lib\site-packages\pymysql\connections.py:599:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>

    def _request_authentication(self):
        # https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
        if int(self.server_version.split('.', 1)[0]) >= 5:
            self.client_flag |= CLIENT.MULTI_RESULTS

        if self.user is None:
            raise ValueError("Did not specify a username")

        charset_id = charset_by_name(self.charset).id
        if isinstance(self.user, text_type):
            self.user = self.user.encode(self.encoding)

        data_init = struct.pack('<iIB23s', self.client_flag, MAX_PACKET_LEN, charset_id, b'')

        if self.ssl and self.server_capabilities & CLIENT.SSL:
            self.write_packet(data_init)

            self._sock = self.ctx.wrap_socket(self._sock, server_hostname=self.host)
            self._rfile = _makefile(self._sock, 'rb')
            self._secure = True

        data = data_init + self.user + b'\0'

        authresp = b''
        plugin_name = None

        if self._auth_plugin_name == '':
            plugin_name = b''
            authresp = _auth.scramble_native_password(self.password, self.salt)
        elif self._auth_plugin_name == 'mysql_native_password':
            plugin_name = b'mysql_native_password'
            authresp = _auth.scramble_native_password(self.password, self.salt)
        elif self._auth_plugin_name == 'caching_sha2_password':
            plugin_name = b'caching_sha2_password'
            if self.password:
                if DEBUG:
                    print("caching_sha2: trying fast path")
                authresp = _auth.scramble_caching_sha2(self.password, self.salt)
            else:
                if DEBUG:
                    print("caching_sha2: empty password")
        elif self._auth_plugin_name == 'sha256_password':
            plugin_name = b'sha256_password'
            if self.ssl and self.server_capabilities & CLIENT.SSL:
                authresp = self.password + b'\0'
            elif self.password:
                authresp = b'\1'  # request public key
            else:
                authresp = b'\0'  # empty password

        if self.server_capabilities & CLIENT.PLUGIN_AUTH_LENENC_CLIENT_DATA:
            data += lenenc_int(len(authresp)) + authresp
        elif self.server_capabilities & CLIENT.SECURE_CONNECTION:
            data += struct.pack('B', len(authresp)) + authresp
        else:  # pragma: no cover - not testing against servers without secure auth (>=5.0)
            data += authresp + b'\0'

        if self.db and self.server_capabilities & CLIENT.CONNECT_WITH_DB:
            if isinstance(self.db, text_type):
                self.db = self.db.encode(self.encoding)
            data += self.db + b'\0'

        if self.server_capabilities & CLIENT.PLUGIN_AUTH:
            data += (plugin_name or b'') + b'\0'

        if self.server_capabilities & CLIENT.CONNECT_ATTRS:
            connect_attrs = b''
            for k, v in self._connect_attrs.items():
                k = k.encode('utf-8')
                connect_attrs += struct.pack('B', len(k)) + k
                v = v.encode('utf-8')
                connect_attrs += struct.pack('B', len(v)) + v
            data += struct.pack('B', len(connect_attrs)) + connect_attrs

        self.write_packet(data)
>       auth_packet = self._read_packet()

..\env\lib\site-packages\pymysql\connections.py:861:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.

        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = b''
        while True:
            packet_header = self._read_bytes(4)
            #if DEBUG: dump_packet(packet_header)

            btrl, btrh, packet_number = struct.unpack('<HBB', packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query")
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id))
            self._next_seq_id = (self._next_seq_id + 1) % 256

            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG: dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xffffff:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break

        packet = packet_type(buff, self.encoding)
>       packet.check_error()

..\env\lib\site-packages\pymysql\connections.py:684:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.protocol.MysqlPacket object at 0x000002365ED32A90>

    def check_error(self):
        if self.is_error_packet():
            self.rewind()
            self.advance(1)  # field_count == error (we already know that)
            errno = self.read_uint16()
            if DEBUG: print("errno =", errno)
>           err.raise_mysql_exception(self._data)

..\env\lib\site-packages\pymysql\protocol.py:220:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x15\x04#28000Access denied for user 'root'@'localhost' (using password: YES)"

    def raise_mysql_exception(data):
        errno = struct.unpack('<h', data[1:3])[0]
        is_41 = data[3:4] == b"#"
        if is_41:
            # client protocol 4.1
            errval = data[9:].decode('utf-8', 'replace')
        else:
            errval = data[3:].decode('utf-8', 'replace')
        errorclass = error_map.get(errno, InternalError)
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (1045, "Access denied for user 'root'@'localhost' (using password: YES)")

..\env\lib\site-packages\pymysql\err.py:109: OperationalError

During handling of the above exception, another exception occurred:

request = <SubRequest 'db' for <Function test_check_all_contacts_data>>

    @pytest.fixture(scope="session", autouse=True)
    def db(request):
        db_config = load_config(request.config.getoption("--target"))['db']
        # dbfixture = DbFixture(host = db_config['host'], name = db_config['name'], user = db_config['user'], password = db_config['password'])
>       dbfixture = ORMFixture(host=db_config['host'], name=db_config['name'], user=db_config['user'], password="db_config['password']")

..\conftest.py:41:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\fixture\orm.py:34: in __init__
    self.db.bind('mysql', host=host, database=name, user=user, password=password)
..\env\lib\site-packages\pony\orm\core.py:765: in bind
    self._bind(*args, **kwargs)
..\env\lib\site-packages\pony\orm\core.py:787: in _bind
    self.provider = provider_cls(*args, **kwargs)
..\env\lib\site-packages\pony\orm\dbapiprovider.py:115: in __init__
    connection, is_new_connection = provider.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

func = <function DBAPIProvider.connect at 0x000002365E3399D8>
provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>
args = (), kwargs = {}
dbapi_module = <module 'pymysql' from 'C:\\Users\\tatyana\\PycharmProjects\\Devel\\env\\lib\\site-packages\\pymysql\\__init__.py'>

    @decorator
    def wrap_dbapi_exceptions(func, provider, *args, **kwargs):
        dbapi_module = provider.dbapi_module
        try:
            if provider.dialect != 'SQLite':
                return func(provider, *args, **kwargs)
            else:
                provider.local_exceptions.keep_traceback = True
                try: return func(provider, *args, **kwargs)
                finally: provider.local_exceptions.keep_traceback = False
        except dbapi_module.NotSupportedError as e: raise NotSupportedError(e)
        except dbapi_module.ProgrammingError as e: raise ProgrammingError(e)
        except dbapi_module.InternalError as e: raise InternalError(e)
        except dbapi_module.IntegrityError as e: raise IntegrityError(e)
        except dbapi_module.OperationalError as e:
            if provider.dialect == 'SQLite': provider.restore_exception()
>           raise OperationalError(e)
E           pony.orm.dbapiprovider.OperationalError: (1045, "Access denied for user 'root'@'localhost' (using password: YES)")

..\env\lib\site-packages\pony\orm\dbapiprovider.py:61: OperationalError


=================================== ERRORS ====================================
_______________ ERROR at setup of test_check_all_contacts_data ________________

func = <function DBAPIProvider.connect at 0x000002365E3399D8>
provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>
args = (), kwargs = {}
dbapi_module = <module 'pymysql' from 'C:\\Users\\tatyana\\PycharmProjects\\Devel\\env\\lib\\site-packages\\pymysql\\__init__.py'>

    @decorator
    def wrap_dbapi_exceptions(func, provider, *args, **kwargs):
        dbapi_module = provider.dbapi_module
        try:
            if provider.dialect != 'SQLite':
>               return func(provider, *args, **kwargs)

..\env\lib\site-packages\pony\orm\dbapiprovider.py:50:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>

    @wrap_dbapi_exceptions
    def connect(provider):
>       return provider.pool.connect()

..\env\lib\site-packages\pony\orm\dbapiprovider.py:215:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pool = <pony.orm.dbapiprovider.Pool object at 0x000002365EC69648>

    def connect(pool):
        pid = os.getpid()
        if pool.con is not None and pool.pid != pid:
            pool.forked_connections.append((pool.con, pool.pid))
            pool.con = pool.pid = None
        core = pony.orm.core
        is_new_connection = False
        if pool.con is None:
            if core.local.debug: core.log_orm('GET NEW CONNECTION')
            is_new_connection = True
>           pool._connect()

..\env\lib\site-packages\pony\orm\dbapiprovider.py:336:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pool = <pony.orm.dbapiprovider.Pool object at 0x000002365EC69648>

    def _connect(pool):
>       pool.con = pool.dbapi_module.connect(*pool.args, **pool.kwargs)

..\env\lib\site-packages\pony\orm\dbapiprovider.py:342:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ()
kwargs = {'charset': 'utf8', 'client_flag': 2, 'conv': {<class 'bool'>: <function escape_bool at 0x000002365E36EAE8>, <class 'i...00002365E36EC80>, <class 'str'>: <function escape_unicode at 0x000002365E36EEA0>, ...}, 'database': 'addressbook', ...}
Connection = <class 'pymysql.connections.Connection'>

    def Connect(*args, **kwargs):
        """
        Connect to the database; see connections.Connection.__init__() for
        more information.
        """
        from .connections import Connection
>       return Connection(*args, **kwargs)

..\env\lib\site-packages\pymysql\__init__.py:94:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
host = '127.0.0.1', user = 'root', password = "db_config['password']"
database = 'addressbook', port = 0, unix_socket = None, charset = 'utf8'
sql_mode = None, read_default_file = None
conv = {<class 'bool'>: <function escape_bool at 0x000002365E36EAE8>, <class 'int'>: <function escape_int at 0x000002365E36EB...'>: <function escape_float at 0x000002365E36EC80>, <class 'str'>: <function escape_unicode at 0x000002365E36EEA0>, ...}
use_unicode = True, client_flag = 3842575
cursorclass = <class 'pymysql.cursors.Cursor'>, init_command = None
connect_timeout = 10, ssl = None, read_default_group = None, compress = None
named_pipe = None, autocommit = False, db = None, passwd = None
local_infile = False, max_allowed_packet = 16777216, defer_connect = False
auth_plugin_map = None, read_timeout = None, write_timeout = None
bind_address = None, binary_prefix = False, program_name = None
server_public_key = None

    def __init__(self, host=None, user=None, password="",
                 database=None, port=0, unix_socket=None,
                 charset='', sql_mode=None,
                 read_default_file=None, conv=None, use_unicode=None,
                 client_flag=0, cursorclass=Cursor, init_command=None,
                 connect_timeout=10, ssl=None, read_default_group=None,
                 compress=None, named_pipe=None,
                 autocommit=False, db=None, passwd=None, local_infile=False,
                 max_allowed_packet=16*1024*1024, defer_connect=False,
                 auth_plugin_map=None, read_timeout=None, write_timeout=None,
                 bind_address=None, binary_prefix=False, program_name=None,
                 server_public_key=None):
        if use_unicode is None and sys.version_info[0] > 2:
            use_unicode = True

        if db is not None and database is None:
            database = db
        if passwd is not None and not password:
            password = passwd

        if compress or named_pipe:
            raise NotImplementedError("compress and named_pipe arguments are not supported")

        self._local_infile = bool(local_infile)
        if self._local_infile:
            client_flag |= CLIENT.LOCAL_FILES

        if read_default_group and not read_default_file:
            if sys.platform.startswith("win"):
                read_default_file = "c:\\my.ini"
            else:
                read_default_file = "/etc/my.cnf"

        if read_default_file:
            if not read_default_group:
                read_default_group = "client"

            cfg = Parser()
            cfg.read(os.path.expanduser(read_default_file))

            def _config(key, arg):
                if arg:
                    return arg
                try:
                    return cfg.get(read_default_group, key)
                except Exception:
                    return arg

            user = _config("user", user)
            password = _config("password", password)
            host = _config("host", host)
            database = _config("database", database)
            unix_socket = _config("socket", unix_socket)
            port = int(_config("port", port))
            bind_address = _config("bind-address", bind_address)
            charset = _config("default-character-set", charset)
            if not ssl:
                ssl = {}
            if isinstance(ssl, dict):
                for key in ["ca", "capath", "cert", "key", "cipher"]:
                    value = _config("ssl-" + key, ssl.get(key))
                    if value:
                        ssl[key] = value

        self.ssl = False
        if ssl:
            if not SSL_ENABLED:
                raise NotImplementedError("ssl module not found")
            self.ssl = True
            client_flag |= CLIENT.SSL
            self.ctx = self._create_ssl_ctx(ssl)

        self.host = host or "localhost"
        self.port = port or 3306
        self.user = user or DEFAULT_USER
        self.password = password or b""
        if isinstance(self.password, text_type):
            self.password = self.password.encode('latin1')
        self.db = database
        self.unix_socket = unix_socket
        self.bind_address = bind_address
        if not (0 < connect_timeout <= 31536000):
            raise ValueError("connect_timeout should be >0 and <=31536000")
        self.connect_timeout = connect_timeout or None
        if read_timeout is not None and read_timeout <= 0:
            raise ValueError("read_timeout should be >= 0")
        self._read_timeout = read_timeout
        if write_timeout is not None and write_timeout <= 0:
            raise ValueError("write_timeout should be >= 0")
        self._write_timeout = write_timeout
        if charset:
            self.charset = charset
            self.use_unicode = True
        else:
            self.charset = DEFAULT_CHARSET
            self.use_unicode = False

        if use_unicode is not None:
            self.use_unicode = use_unicode

        self.encoding = charset_by_name(self.charset).encoding

        client_flag |= CLIENT.CAPABILITIES
        if self.db:
            client_flag |= CLIENT.CONNECT_WITH_DB

        self.client_flag = client_flag

        self.cursorclass = cursorclass

        self._result = None
        self._affected_rows = 0
        self.host_info = "Not connected"

        # specified autocommit mode. None means use server default.
        self.autocommit_mode = autocommit

        if conv is None:
            conv = converters.conversions

        # Need for MySQLdb compatibility.
        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}
        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}
        self.sql_mode = sql_mode
        self.init_command = init_command
        self.max_allowed_packet = max_allowed_packet
        self._auth_plugin_map = auth_plugin_map or {}
        self._binary_prefix = binary_prefix
        self.server_public_key = server_public_key

        self._connect_attrs = {
            '_client_name': 'pymysql',
            '_pid': str(os.getpid()),
            '_client_version': VERSION_STRING,
        }

        if program_name:
            self._connect_attrs["program_name"] = program_name

        if defer_connect:
            self._sock = None
        else:
>           self.connect()

..\env\lib\site-packages\pymysql\connections.py:325:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG: print('connected using unix_socket')
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs['source_address'] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG: print('connected using socket')
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, 'rb')
            self._next_seq_id = 0

            self._get_server_information()
>           self._request_authentication()

..\env\lib\site-packages\pymysql\connections.py:599:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>

    def _request_authentication(self):
        # https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
        if int(self.server_version.split('.', 1)[0]) >= 5:
            self.client_flag |= CLIENT.MULTI_RESULTS

        if self.user is None:
            raise ValueError("Did not specify a username")

        charset_id = charset_by_name(self.charset).id
        if isinstance(self.user, text_type):
            self.user = self.user.encode(self.encoding)

        data_init = struct.pack('<iIB23s', self.client_flag, MAX_PACKET_LEN, charset_id, b'')

        if self.ssl and self.server_capabilities & CLIENT.SSL:
            self.write_packet(data_init)

            self._sock = self.ctx.wrap_socket(self._sock, server_hostname=self.host)
            self._rfile = _makefile(self._sock, 'rb')
            self._secure = True

        data = data_init + self.user + b'\0'

        authresp = b''
        plugin_name = None

        if self._auth_plugin_name == '':
            plugin_name = b''
            authresp = _auth.scramble_native_password(self.password, self.salt)
        elif self._auth_plugin_name == 'mysql_native_password':
            plugin_name = b'mysql_native_password'
            authresp = _auth.scramble_native_password(self.password, self.salt)
        elif self._auth_plugin_name == 'caching_sha2_password':
            plugin_name = b'caching_sha2_password'
            if self.password:
                if DEBUG:
                    print("caching_sha2: trying fast path")
                authresp = _auth.scramble_caching_sha2(self.password, self.salt)
            else:
                if DEBUG:
                    print("caching_sha2: empty password")
        elif self._auth_plugin_name == 'sha256_password':
            plugin_name = b'sha256_password'
            if self.ssl and self.server_capabilities & CLIENT.SSL:
                authresp = self.password + b'\0'
            elif self.password:
                authresp = b'\1'  # request public key
            else:
                authresp = b'\0'  # empty password

        if self.server_capabilities & CLIENT.PLUGIN_AUTH_LENENC_CLIENT_DATA:
            data += lenenc_int(len(authresp)) + authresp
        elif self.server_capabilities & CLIENT.SECURE_CONNECTION:
            data += struct.pack('B', len(authresp)) + authresp
        else:  # pragma: no cover - not testing against servers without secure auth (>=5.0)
            data += authresp + b'\0'

        if self.db and self.server_capabilities & CLIENT.CONNECT_WITH_DB:
            if isinstance(self.db, text_type):
                self.db = self.db.encode(self.encoding)
            data += self.db + b'\0'

        if self.server_capabilities & CLIENT.PLUGIN_AUTH:
            data += (plugin_name or b'') + b'\0'

        if self.server_capabilities & CLIENT.CONNECT_ATTRS:
            connect_attrs = b''
            for k, v in self._connect_attrs.items():
                k = k.encode('utf-8')
                connect_attrs += struct.pack('B', len(k)) + k
                v = v.encode('utf-8')
                connect_attrs += struct.pack('B', len(v)) + v
            data += struct.pack('B', len(connect_attrs)) + connect_attrs

        self.write_packet(data)
>       auth_packet = self._read_packet()

..\env\lib\site-packages\pymysql\connections.py:861:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.connections.Connection object at 0x000002365E42B320>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.

        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = b''
        while True:
            packet_header = self._read_bytes(4)
            #if DEBUG: dump_packet(packet_header)

            btrl, btrh, packet_number = struct.unpack('<HBB', packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query")
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id))
            self._next_seq_id = (self._next_seq_id + 1) % 256

            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG: dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xffffff:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break

        packet = packet_type(buff, self.encoding)
>       packet.check_error()

..\env\lib\site-packages\pymysql\connections.py:684:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pymysql.protocol.MysqlPacket object at 0x000002365ED32A90>

    def check_error(self):
        if self.is_error_packet():
            self.rewind()
            self.advance(1)  # field_count == error (we already know that)
            errno = self.read_uint16()
            if DEBUG: print("errno =", errno)
>           err.raise_mysql_exception(self._data)

..\env\lib\site-packages\pymysql\protocol.py:220:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\xff\x15\x04#28000Access denied for user 'root'@'localhost' (using password: YES)"

    def raise_mysql_exception(data):
        errno = struct.unpack('<h', data[1:3])[0]
        is_41 = data[3:4] == b"#"
        if is_41:
            # client protocol 4.1
            errval = data[9:].decode('utf-8', 'replace')
        else:
            errval = data[3:].decode('utf-8', 'replace')
        errorclass = error_map.get(errno, InternalError)
>       raise errorclass(errno, errval)
E       pymysql.err.OperationalError: (1045, "Access denied for user 'root'@'localhost' (using password: YES)")

..\env\lib\site-packages\pymysql\err.py:109: OperationalError

During handling of the above exception, another exception occurred:

request = <SubRequest 'db' for <Function test_check_all_contacts_data>>

    @pytest.fixture(scope="session", autouse=True)
    def db(request):
        db_config = load_config(request.config.getoption("--target"))['db']
        # dbfixture = DbFixture(host = db_config['host'], name = db_config['name'], user = db_config['user'], password = db_config['password'])
>       dbfixture = ORMFixture(host=db_config['host'], name=db_config['name'], user=db_config['user'], password="db_config['password']")

..\conftest.py:41:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\fixture\orm.py:34: in __init__
    self.db.bind('mysql', host=host, database=name, user=user, password=password)
..\env\lib\site-packages\pony\orm\core.py:765: in bind
    self._bind(*args, **kwargs)
..\env\lib\site-packages\pony\orm\core.py:787: in _bind
    self.provider = provider_cls(*args, **kwargs)
..\env\lib\site-packages\pony\orm\dbapiprovider.py:115: in __init__
    connection, is_new_connection = provider.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

func = <function DBAPIProvider.connect at 0x000002365E3399D8>
provider = <pony.orm.dbproviders.mysql.MySQLProvider object at 0x000002365E42B2B0>
args = (), kwargs = {}
dbapi_module = <module 'pymysql' from 'C:\\Users\\tatyana\\PycharmProjects\\Devel\\env\\lib\\site-packages\\pymysql\\__init__.py'>

    @decorator
    def wrap_dbapi_exceptions(func, provider, *args, **kwargs):
        dbapi_module = provider.dbapi_module
        try:
            if provider.dialect != 'SQLite':
                return func(provider, *args, **kwargs)
            else:
                provider.local_exceptions.keep_traceback = True
                try: return func(provider, *args, **kwargs)
                finally: provider.local_exceptions.keep_traceback = False
        except dbapi_module.NotSupportedError as e: raise NotSupportedError(e)
        except dbapi_module.ProgrammingError as e: raise ProgrammingError(e)
        except dbapi_module.InternalError as e: raise InternalError(e)
        except dbapi_module.IntegrityError as e: raise IntegrityError(e)
        except dbapi_module.OperationalError as e:
            if provider.dialect == 'SQLite': provider.restore_exception()
>           raise OperationalError(e)
E           pony.orm.dbapiprovider.OperationalError: (1045, "Access denied for user 'root'@'localhost' (using password: YES)")

..\env\lib\site-packages\pony\orm\dbapiprovider.py:61: OperationalError